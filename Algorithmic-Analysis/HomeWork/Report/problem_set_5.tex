\begin{center}
  \Large{\cyr{\textbf{Завдання №5}}}
\end{center}


\begin{center}
  \normalize{\cyr{\textbf{Завдання з загального файлу завдань було замінене на наступне за згодою викладача}}}
\end{center}

\begin{quote} \textbf{Завдання}:
Заповнити  довільно великий масив випадковими числовими данними і відсортувати його кількома (2 два ніби замало, а три щоб різна complexity не набереться) різними алгоритмами сортуваня з різною складністю виконання ($O (n \log{n})$, $O(n^2)$)

Протестувати усі імплементовані алгоритми і написати висновки щодо часу і простороу складності алгоритмів.
\end{quote}

\begin{center}
  \normalize{\cyr{\textbf{Імплементовані алгоритми сортування:}}}
\end{center}

\begin{enumerate}
  \item Сортування мотодом Бульбашок
  \item Сортування Вибіркою
  \item Сортування Вставкою
  \item Сортування Вставкою (з заміною елементів)\footnote{демонстраційний зразок змін які відбуваються з швидкодією коли замість замість однієї заміни ввести зміну обох зміниих}
  \item Сортування Злиттям
  \item Швидке сортування
  \end{enumerate}

\begin{center}
  \normalize{\cyr{\textbf{Тестувались алгоритми сортування наступним чином:}}}
\end{center}

\begin{enumerate}
  \item Генерувалось 100 масивів випадкових чисел різною довжиною n ( $2^8$, $2^{10}$, $2^{16}$ і $2^{21}$).
  \item Программа сортувальник ($\normalsize\texttt{problem\_5\_sort.cpp}$) отримувала на вході алгоритм що підлягав тестуванню і сам масив.
  \item Час що витрачався на сортування замірявся (за допомогою $\normalsize\texttt{timer.c}$) на вході і виході, різниця записувалась в журнал.
  \item По-кожном з алгоритмів сортування вираховувалось середнє значення від якого віднімалось середнє значення ініціалізації программи та отримання данних.
  \end{enumerate}

\begin{center}
  \normalize{\cyr{\textbf{Інструменти:}}}
\end{center}

\begin{enumerate}
  \item Сортувальник ($\normalsize\texttt{problem\_5\_sort.cpp}$) программа що отримувала на вході один з попередньо імплементованих алгоритмів сортування та масц з цілих числе як аргумент. Программа не виводила абсолютно нічого і займалась лише там що запускала механізм сортування для отриманого масиву.

  Компіляція: \\
  $\normalsize\texttt{c++ problem\_5\_sort.cpp code.cpp -o sorter -std=c++11}$

  \item Таймер ($\normalsize\texttt{timer.c}$) - повертав системний час у форматі unixtimestamp і мікросекунд.

  Компіляція: \\
  $\normalsize\texttt{c++ timer.cpp -o timer -std=c++11}$

  \item Генератор довільного масиву $\normalsize\texttt{problem\_5\_generate.cpp}$, программа, що просто генерує массив довільних значень.

  Компіляція: \\
  $\normalsize\texttt{c++ problem\_5\_generate.cpp code.cpp -o generate -std=c++11}$

  \item Генерація тестових данних - скрипт  ($\normalsize\texttt{tests.sh}$) написаний для Bourne again shell, що генерує тестові масиви, запускає тестування імплементованих алгоритмів сортування та протоколює метрики.

  \item Аналізатор метрик (  $\normalsize\texttt{report.py}$) - скрипт написаний на Python3 що читає наші рапорти з метриками і видає на їх основі \LaTeX сумісну відповідь.
\end{enumerate}

\begin{center}
  \normalize{\cyr{\textbf{Таблиця результатів:}}}
\end{center}

\begin{center}
  \begin{tabular}{| l | c c c c|}
    \hline
    \multirow{Алгоритми} & \multicolumn{4}{ |c| }{ Розмір масиву цілих чисел } \\
                                      & 2^8 &  2^{16} & 2^{16} & 2^{21} \\
    \hline
    QuickSort        & 0.0003 &  0.0001 &  0.0109 &  0.3572  \\ \hline
    MergeSort        & 0.0004 &  0.0001 &  0.0325 &  0.9553  \\ \hline
    Insertion        & 0.0004 &  0.0009 &  0.3594 &  11.6863 \\ \hline
    Selection        & 0.0006 &  0.0017 &  0.5029 &  15.9639 \\ \hline
    Insertion*       & 0.0004 &  0.0030 &  1.0228 &  33.7722 \\ \hline
    BubbleSort       & 0.0005 &  0.0053 &  1.6633 &  53.1013 \\ \hline
  \end{tabular}
\end{center}

Таблиця показу середню швидкість в секундах на сортування (за мінусом середнього часу на ініціалізацію).

\begin{center}
  \normalize{\cyr{\textbf{Висновки:}}}
\end{center}

\begin{itemize}
  \item На невеликих масивих інколи краще використовувати алгоритми з складністю $O(n^2)$ - оскільки в данному випадку приріст швидкодії відбувається саме через простоту алгоритму сортуванняь наприклад на масивах розміром $2^4$ InsertionSort побив QuickSort (результат проміжних тестів).
  \item Лінійні (відсутні у данному наборі), лінійно логарифмічні та квадратичні алгоритми седуть себе відповідно до своїх класифікацій у відношенні до збільшення/або зменшення обєму вхідних данних - але це ріст/спа д неє чітко квадратичним (окрім як у випадку бульбашкового сортування) чи лінійно-логарифмічним і загалом залежить від того як саме розташовані алементи в масиві. Іншими словами - ``найгірший'' випадок зустрічається вкрай рідко.
  \item Алгоритми одного класу складності різняттся між собою доволі значно, тому слід уважно обирати алгоритм сортування зважаючи на обєм вхідних данних.
  \item Має місце імплементації складніших алгоритмів сортування що зважать на розмір, тип вхідних данних, наприклад у відповідності від розміру данних використовувати різні алгоритми щ гарантуватимуть більш швидкий результ.
  \item Існують різні імплементації спец алгоритмів що працюють на спеціальних структурах данних, що гарантують не тільки швидке сортування але і швидкий пошук і видалення з структури (напраклад двійкові дерева тощо).
\end{itemize}
